# 编译和运行

**参考文档**

[10 分钟看懂 C++ 编译过程](https://oicebot.github.io/2020/03/20/c-compilers-explained.html)

---

## 什么是编译

编译就是把程序员编写的人类可读的代码转换成机器可执行的代码的过程，这一过程由编译器完成，它将源代码作为输入，最终输出可执行的二进制代码，填补了高级 C++ 语言和机器语言之间的空白。

&emsp;

## 编译的阶段

### 预处理 (Preprocessing)

在实际编译工作开始之前，预处理器指令指示编译器对源码进行临时扩充，以为之后的步骤做好准备。在 C++ 中，预处理器指令以 `#` 号开头，比如 `#include`、`#define` 和 `#if` 等。在这一阶段，编译器逐个处理 C++ 源码文件。对于 `#define` 指令，编译器将源码中的宏替换成宏定义中的内容；对于 `#if`、`#ifdef` 和 `#ifndef` 指令，编译器将有选择地跳过或选中部分源代码；而对于 `#include` 指令，编译器将把对应的库的源码插入到当前源代码中——这通常是一些通用的声明。被 `#include` 指令引入的头文件（ `.h` ）往往会包含大量的代码，你引入的越多，最后生成的预编译文件就越大。总的来说，预编译过的文件会比原来的 C++ 源码更大一些。我们通过下面这个代码为例说明。

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("Hello World\n");
    return EXIT_SUCCESS;
}
```

根据习惯，如果需要引入 C/C++ 标准头文件，采用 `#include <>` ，而如果是自己定义的头文件则是 `#include ""`。头文件大多数都包含三类信息，函数原型 (function prototype)，宏定义 (macro definitions) 和 类型定义 (type definitions)。函数原型会告诉编译器有这样一个函数存在于项目的某个位置中，它同时包含了函数的详细信息，例如参数类型，个数和返回值类型，便于编译器进行检查。上述代码中的 `EXIT_SUCCESS` 便是一种宏定义。使用宏定义可以提升代码的可读性，同时方便对其值进行更改。

通过上面这些替换和插入操作，预处理器产生的是被合为一体的输出文件。预处理器还会在代码中插入记号，使编译器能分辨出每一行来自哪个文件，以便在调试过程中能生成对应的错误信息。在开发调试你的 C++ 程序时，这些错误信息能给你很多帮助。

&emsp;

### 编译 (Compilation)

预处理的结果会存放在一个临时文件中然后传递给编译器，编译器将去除了预编处理器指令的纯 C++ 代码编译成底层汇编代码 (assembly)。编译的过程其实就是解析代码的过程，确保语法正确。在转换成汇编的过程中，程序员可以通过加上 `-O` 的参数要求编译器对代码进行优化，确保生成的汇编运行更加迅速。

&emsp;

### 汇编 (Assembly)

在这一步，汇编器将上一步生成的汇编代码逐行转换成字节码（也就是机器码）。实际上，如果你希望把代码的不同部分分开编译的话，编译过程在这一步之后就可以停止了。通过加上 `-c` 选项，例如 `gcc -c main.c` ，生成的目标文件的命名默认和源文件保持一致，只是更改了文件后缀变成 `.o`，即 `main.o`。如果希望自己指定文件名称，通过 `gcc -c main.c -o otherName.o` 即可。

这一步生成的目标文件可以被放在被称为静态库的包中，以备后续使用。也就是说，如果你只修改了一个文件，你并不需要重新编译整个项目的源代码，这对于大型项目非常关键。

&emsp;

### 链接 (Linking)

链接器利用编译器产生的目标文件，生成最终结果。在这一阶段，编译器将把上一阶段中编译器产生的各种目标文件链接起来，将未定义标识符的引用全部替换成它们对应的正确地址。没有把目标文件链接起来，就无法生成能够正常工作的程序，就像一页没有页码的目录一样，没什么用处。完成链接工作之后，链接器根据编译目的不同，把链接的结果生成为一个动态链接库，或是一个可执行文件。

链接的过程也会抛出各种异常，通常是重复定义或者缺失定义等错误。不只是没进行定义的情况，如果你忘记将对某个库或是目标文件的引用导入进来，让链接器能找到定义的话，也会发生这类错误。重复定义则刚好相反，当有两个库或目标文件中含有对同一个标识符的定义时，就可能出现重复定义错误。

&emsp;

## 如何使用 C++ 编译器

构建并运行一个 C++ 程序所需的基本步骤有：

1. 使用一个编辑器或是编程环境（IDE），构建一个语法正确的 C++ 源文件。
2. 运行编译器对源文件进行编译，生成可执行文件。
3. 运行生成的文件。

编译器的特性差异很大，即使在同一个编译器的不同版本之间也是这样；同样，它们的选项也非常丰富，比如在代码生成、调试、浮点数行为、库处理等方面，都有着相当多的选项。

&emsp;

## g++ 重要编译参数

1. **-O[n] 优化源代码**
   
   所谓优化，就是省略掉代码中从未使用过的变量、直接将常量表达式用结果值代替等等这些操作，会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。（n 常为 0–3）。

2. **-l和 -L 指定库文件｜指定库文件路径**
   
   ```bash
   # -l 参数(小写)就是用来指定程序要链接的库，-l参数紧接着就是库名
   # 在 /lib 和 /usr/lib 和 /usr/local/lib 里的库直接用 -l 参数就能链接
   # 链接 glog 库
   g++ -lglog test.cpp
   
   # 如果库文件没放在上面三个目录里，需要使用 -L 参数(大写)指定库文件所在目录
   # -L 参数跟着的是库文件所在的目录名
   # 链接 mytest 库，libmytest.so 在 /home/bing/mytestlibfolder 目录下
   g++ -L/home/bing/mytestlibfolder -lmytest test.cpp
   ```

3. **-Wall 打印警告信息**
   
   ```bash
   # 打印出 gcc 提供的警告信息
   g++ -Wall test.cpp
   ```

4. **-D 定义宏**
   
   常用场景：`-DDEBUG` 定义 `DEBUG` 宏，可能文件中有 `DEBUG` 宏部分的相关信息，
   用这个来选择开启或关闭 `DEBUG`。示例如下：
   
   ```cpp
   #include <stdio.h>
   int main()
   {
       #ifdef DEBUG
           printf("DEBUG LOG\n");
       #endif
           printf("in\n");
   }
   // 1.在编译的时候，使用 gcc -DDEBUG main.cpp
   // 2.第七行代码可以被执行
   ```

5. **-I 指定头文件搜索目录**
   
   ```bash
   # -I
   # /usr/include 目录一般是不用指定的， gcc 知道去那里找
   # 但是如果头文件不在 /usr/icnclude 里我们就要用 -I 参数指定了，比如头文件放在 /myinclude 目录里，
   # 那编译命令行就要加上 -I/myinclude 参数了，如果不加你会得到一个 ”xxxx.h: No such file or directory”的错误。
   # -I 参数可以用相对路径，比如头文件在当前目录，可以用-I.来指定。
   
   g++ -I/myinclude test.cpp
   ```
