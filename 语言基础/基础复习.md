# 基础复习

## 关键词 typedef

把一个类型名称转换成更具业务含义的名字，帮助提升代码可读性。

```c
typedef unsigned int rgb_t;

rgb_t getRedForPixel(int x, int y) {...}
rgb_t getGreenForPixel(int x, int y) {...}
rgb_t getBlueForPixel(int x, int y) {...}
```

## Enum 类型

```c
enum treat_level_t {
    LOW,
    GUARDED,
    ELEVATED,
    HIGH,
    SEVERE
};
```

从上至下有默认值，从 0 开始。

&emsp;

## 访问其他文件中的函数

在头文件中做声明，在同名的源文件中做相关定义。当其他文件需要调用时，只需声明 #include "xxx.h" 即可，注意导入头文件的时候，如果需要自定义文件，要用双引号。

&emsp;

## 指针与引用

### 内存分析

程序在执行时会开辟一些内存空间来存储数据，内存可以分成四个区域：栈区，堆区，全局区，代码区。

* 代码区：存放程序编译之后生成的二进制代码，例如我们写的函数。

* 全局区：全局区的变量在程序编译阶段已经分配好内存空间并初始化，这款内存在程序的整个运行期间都存在，主要存放静态变量，全局变量和常量。

```c
#include <iostream>

int v1 = 10;                // 全局变量
const int v2 = 20;          // 全局常量
static int v3 = 30;         // 静态变量
static const int v4 = 40;   // 静态常量

int main() {...}
```

* 栈区：系统进行内存管理，主要存放函数的参数和局部变量。

* 堆区：由程序员手动释放，如果不释放程序结束后由系统回收，生命周期是整个运行期间。

&emsp;

### 野指针和空指针

空指针：没有存储任何地址的指针。

野指针：指针变量中确实存储了一个内存地址，但是这个地址指向的空间不存在了。

&emsp;

### 常量指针和指针常量

常量指针：指向常量的指针，指针指向的空间的值是不可以修改的，但是指针的指向可以修改

指针常量：表示指针是一个常量值，可以通过指针来修改指向空间的值，但是不能修改指针的地址指向。

```c
int main() {
    int num1 = 10;
    int num2 = 8;
    
    // 常量指针
    const int* p1 = &num1;
    *p1 = 20;                // 操作不被允许
    p1 = &num2;              // 更改指针指向是允许

    // 指针常量
    int* const p2 = &num1;
    p2 = &num2;              // 操作不被允许
    *p2 = 20;                // 更改指针地址空间的值是允许的
}
```

&emsp;

### 指针和结构体

```c
struct my_struct {
    int* p;
    int num;
}

struct my_struct m;
struct my_struct* q = &m;
// 代表访问结构体中的指针，获取它指向的值
// 相当于 *(m.p);
int a1 = *m.p;

// 访问结构体中的元素
int a2 = q -> num;
```

&emsp;

### 引用

引用可以作为一个已经定义变量的别名，语法结构是 `Type& ref = val;`，**引用的本质是一个指针常量**。

引用有几点需要注意：

* 必须在声明引用变量时候进行初始化

* 引用初始化后不能更改

* 不能有 NULL 引用，必须确保引用和一块合法的存储单元相关联。

常量引用：主要用在函数参数入参，表示该函数不可以更改其值。

&emsp;

## 数组

语法格式：`数据类型 标识符[长度]`

常见的定义方法：

```c
int array1[5];        //定义指定长度的数组但是没有初始化
int array2[5] = {0, 1, 2, 3, 4};    // 定义指定长度数组同时初始化所有元素
int array3[5] = {1, 2};    // 定义指定长度数组，初始化部分元素，未初始化默认是0
int array4[] = {1, 2, 3, 4};    // 不指定长度，长度由初始化元素数量决定
```

需要注意的是，在 C/C++ 中，当数组作为参数传递到一个函数中的时候，传递的只是首元素的地址。

```c
void print_array(int* array, int len) {
    for (int i = 0; i < len; i++) {
        std::cout << array[i] << std::endl;
    }
}
```

除了上述这种，还可以通过元素迭代访问

```c
for (int i : array2) {
    cout << i << endl;
}
```

需要注意元素迭代访问的这种方式只能够访问元素而不能更改，**而且只能在定义数组的部分使用，如果将数组通过参数传递到另外一个函数，此时是不能使用这种方式的**。
